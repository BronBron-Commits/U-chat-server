[1mdiff --git a/auth-api/src/main.rs b/auth-api/src/main.rs[m
[1mindex fb59882..e912373 100644[m
[1m--- a/auth-api/src/main.rs[m
[1m+++ b/auth-api/src/main.rs[m
[36m@@ -35,7 +35,7 @@[m [masync fn login_handler([m
     }[m
 [m
     let exp = chrono::Utc::now().timestamp() as usize + 3600;[m
[31m-    let claims = Claims { sub: payload.username.clone(), exp };[m
[32m+[m[32m    let claims = Claims { sub: payload.username, exp };[m
 [m
     let token = encode([m
         &Header::default(),[m
[36m@@ -48,11 +48,8 @@[m [masync fn login_handler([m
 [m
 #[tokio::main][m
 async fn main() {[m
[31m-    let secret = std::env::var("JWT_SECRET")[m
[31m-        .unwrap_or_else(|_| "supersecret".into());[m
[31m-[m
     let state = Arc::new(AppState {[m
[31m-        jwt_secret: secret,[m
[32m+[m[32m        jwt_secret: "supersecretjwtkey".into(),[m
     });[m
 [m
     let app = Router::new()[m
[1mdiff --git a/gateway-service/src/main.rs b/gateway-service/src/main.rs[m
[1mindex 8d36fd7..918524a 100644[m
[1m--- a/gateway-service/src/main.rs[m
[1m+++ b/gateway-service/src/main.rs[m
[36m@@ -3,8 +3,7 @@[m [muse axum::{[m
         ws::{Message, WebSocket},[m
         Query, State, WebSocketUpgrade,[m
     },[m
[31m-    http::StatusCode,[m
[31m-    response::{Response, IntoResponse},[m
[32m+[m[32m    response::{IntoResponse, Html, Response},[m
     routing::get,[m
     Router,[m
 };[m
[36m@@ -19,7 +18,7 @@[m [mstruct AppState {[m
     tx: broadcast::Sender<String>,[m
 }[m
 [m
[31m-#[derive(Deserialize, Debug)][m
[32m+[m[32m#[derive(Deserialize)][m
 struct WsQuery {[m
     token: String,[m
 }[m
[36m@@ -37,69 +36,49 @@[m [masync fn main() {[m
 [m
     let listener = tokio::net::TcpListener::bind("0.0.0.0:9000")[m
         .await[m
[31m-        .expect("Failed to bind");[m
[32m+[m[32m        .unwrap();[m
 [m
[31m-    axum::serve(listener, app).await.unwrap();[m
[32m+[m[32m    axum::serve(listener, app.into_make_service())[m
[32m+[m[32m        .await[m
[32m+[m[32m        .unwrap();[m
 }[m
 [m
 async fn ws_handler([m
     ws: WebSocketUpgrade,[m
[32m+[m[32m    Query(WsQuery { token }): Query<WsQuery>,[m
     State(state): State<Arc<AppState>>,[m
[31m-    Query(query): Query<WsQuery>,[m
 ) -> Response {[m
[32m+[m[32m    let validation = Validation::default();[m
[32m+[m[32m    let key = DecodingKey::from_secret(b"secret");[m
 [m
[31m-    // DEBUG: show the raw token the gateway received[m
[31m-    println!("GATEWAY RECEIVED TOKEN: {}", query.token);[m
[31m-[m
[31m-    let secret = std::env::var("JWT_SECRET").unwrap_or_else(|_| "supersecret".into());[m
[31m-[m
[31m-    let mut validation = Validation::default();[m
[31m-    validation.leeway = 300;[m
[31m-    validation.validate_exp = true;[m
[31m-    validation.iss = None;[m
[31m-    validation.sub = None;[m
[31m-    validation.aud = None;[m
[31m-[m
[31m-    let token_check = decode::<serde_json::Value>([m
[31m-        &query.token,[m
[31m-        &DecodingKey::from_secret(secret.as_bytes()),[m
[31m-        &validation,[m
[31m-    );[m
[31m-[m
[31m-    if let Err(e) = &token_check {[m
[31m-        println!("JWT ERROR: {}", e);[m
[31m-        return (StatusCode::UNAUTHORIZED, "INVALID TOKEN").into_response();[m
[32m+[m[32m    if decode::<serde_json::Value>(&token, &key, &validation).is_err() {[m
[32m+[m[32m        return Html("INVALID TOKEN").into_response();[m
     }[m
 [m
[31m-    println!("TOKEN VERIFIED OK");[m
[31m-[m
[31m-    ws.on_upgrade(move |socket| async move {[m
[31m-        handle_socket(socket, state).await;[m
[31m-    })[m
[32m+[m[32m    ws.on_upgrade(move |socket| handle_socket(socket, state))[m
[32m+[m[32m        .into_response()[m
 }[m
 [m
 async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {[m
[31m-    let (mut sender, mut receiver) = socket.split();[m
[32m+[m[32m    let (mut write, mut read) = socket.split();[m
     let mut rx = state.tx.subscribe();[m
 [m
     let send_task = tokio::spawn(async move {[m
         while let Ok(msg) = rx.recv().await {[m
[31m-            if sender.send(Message::Text(msg)).await.is_err() {[m
[32m+[m[32m            if write.send(Message::Text(msg)).await.is_err() {[m
                 break;[m
             }[m
         }[m
     });[m
 [m
[31m-    let state2 = state.clone();[m
[31m-[m
     let recv_task = tokio::spawn(async move {[m
[31m-        while let Some(Ok(Message::Text(msg))) = receiver.next().await {[m
[31m-            let _ = state2.tx.send(msg);[m
[32m+[m[32m        while let Some(Ok(Message::Text(text))) = read.next().await {[m
[32m+[m[32m            let _ = state.tx.send(text);[m
         }[m
     });[m
 [m
     tokio::select! {[m
[31m-        _ = send_task => {},[m
[31m-        _ = recv_task => {},[m
[32m+[m[32m        _ = send_task => (),[m
[32m+[m[32m        _ = recv_task => (),[m
     }[m
 }[m
[1mdiff --git a/run-all.sh b/run-all.sh[m
[1mindex 3b103c5..af918e0 100755[m
[1m--- a/run-all.sh[m
[1m+++ b/run-all.sh[m
[36m@@ -1,28 +1,38 @@[m
 #!/usr/bin/env bash[m
 [m
[31m-# Kill any leftover processes[m
[31m-pkill -f "auth-api|gateway-service|chat-service|presence-service|history-service|bot-service" 2>/dev/null[m
[32m+[m[32mSESSION="unhidra-ms"[m
 [m
[31m-# Export the shared JWT secret[m
[31m-export JWT_SECRET="supersecret"[m
[32m+[m[32mtmux has-session -t $SESSION 2>/dev/null[m
[32m+[m[32mif [ $? -eq 0 ]; then[m
[32m+[m[32m    echo "Killing existing session $SESSION..."[m
[32m+[m[32m    tmux kill-session -t $SESSION[m
[32m+[m[32mfi[m
 [m
[31m-# Go to project dir[m
[31m-cd ~/unhidra-rust[m
[32m+[m[32mecho "Starting new tmux session: $SESSION"[m
 [m
[31m-# Create a logs directory if missing[m
[31m-mkdir -p logs[m
[32m+[m[32m# GATEWAY[m
[32m+[m[32mtmux new-session -d -s $SESSION -n gateway[m
[32m+[m[32mtmux send-keys -t $SESSION:0 "cd ~/unhidra-rust/gateway-service && cargo run" C-m[m
 [m
[31m-echo "Starting UNHIDRA stack..."[m
[32m+[m[32m# AUTH-API (REAL LOGIN SERVER)[m
[32m+[m[32mtmux new-window -t $SESSION -n auth-api[m
[32m+[m[32mtmux send-keys -t $SESSION:1 "cd ~/unhidra-rust/auth-api && cargo run" C-m[m
 [m
[31m-# Launch each service silently in background[m
[31m-./target/release/auth-api          > logs/auth.log       2>&1 &[m
[31m-./target/release/gateway-service   > logs/gateway.log    2>&1 &[m
[31m-./target/release/chat-service      > logs/chat.log       2>&1 &[m
[31m-./target/release/presence-service  > logs/presence.log   2>&1 &[m
[31m-./target/release/history-service   > logs/history.log    2>&1 &[m
[31m-./target/release/bot-service       > logs/bot.log        2>&1 &[m
[32m+[m[32m# CHAT[m
[32m+[m[32mtmux new-window -t $SESSION -n chat[m
[32m+[m[32mtmux send-keys -t $SESSION:2 "cd ~/unhidra-rust/chat-service && cargo run" C-m[m
 [m
[31m-sleep 1[m
[32m+[m[32m# HISTORY[m
[32m+[m[32mtmux new-window -t $SESSION -n history[m
[32m+[m[32mtmux send-keys -t $SESSION:3 "cd ~/unhidra-rust/history-service && cargo run" C-m[m
 [m
[31m-echo "All services launched."[m
[31m-echo "Use 'tail -f logs/<file>.log' to view output."[m
[32m+[m[32m# PRESENCE[m
[32m+[m[32mtmux new-window -t $SESSION -n presence[m
[32m+[m[32mtmux send-keys -t $SESSION:4 "cd ~/unhidra-rust/presence-service && cargo run" C-m[m
[32m+[m
[32m+[m[32m# BOT[m
[32m+[m[32mtmux new-window -t $SESSION -n bot[m
[32m+[m[32mtmux send-keys -t $SESSION:5 "cd ~/unhidra-rust/bot-service && cargo run" C-m[m
[32m+[m
[32m+[m[32mecho "All microservices launched."[m
[32m+[m[32mecho "Attach with:   tmux attach -t $SESSION"[m
